package Days

class Day16 : AlgosBase() {
    override fun Basic(input : MutableList<String>) : Long {
        return ParseInput(input, TREQUESTTYPE.BASIC)
    }

    override fun Advanced(input : MutableList<String>) : Long {
        return ParseInput(input, TREQUESTTYPE.ADVANCED)
    }

    //region Private
    private class Code(val hex : String) {
        private val _Binary : String
        private val _Packets = mutableListOf<PacketBase>()
        private val PACKETHEADER = 6
        private val TYPEIDBIT = 1
        private data class ReadResult(var bitsRead : Int, var resultOperation : Long = 0)
        private val operations = mapOf<Int, (MutableList<ReadResult>) -> Long>(
            0 to ::Op_Sum,
            1 to ::Op_Product,
            2 to ::Op_Minimum,
            3 to ::Op_Maximum,
            5 to ::Op_GreaterThan,
            6 to ::Op_LessThan,
            7 to ::Op_Equal
        )
        private fun Op_Sum(subPackets : MutableList<ReadResult>) : Long = subPackets.sumOf { it.resultOperation }
        private fun Op_Product(subPackets : MutableList<ReadResult>) : Long {
            var retValue : Long = 1
            subPackets.forEach { retValue *= it.resultOperation }
            return retValue
        }
        private fun Op_Minimum(subPackets : MutableList<ReadResult>) : Long = subPackets.minOf { it.resultOperation }
        private fun Op_Maximum(subPackets : MutableList<ReadResult>) : Long = subPackets.maxOf { it.resultOperation }
        private fun Op_GreaterThan(subPackets : MutableList<ReadResult>) : Long = if(subPackets[0].resultOperation > subPackets[1].resultOperation) 1 else 0
        private fun Op_LessThan(subPackets : MutableList<ReadResult>) : Long = if(subPackets[0].resultOperation < subPackets[1].resultOperation) 1 else 0
        private fun Op_Equal(subPackets : MutableList<ReadResult>) : Long = if(subPackets[0].resultOperation == subPackets[1].resultOperation) 1 else 0

        init {
            _Binary = hex.ConvertToBinary()
        }

        fun DoWork() : ResultWork {
            val result = ReadPacket(_Binary)
            return ResultWork(_Packets, result.resultOperation)
        }

        private fun ReadPacket(datas : String) : ReadResult {
            val version = datas.substring(0..2).toInt(2)
            val typeID = datas.substring(3..5).toInt(2)
            return when (typeID) {
                4 -> {
                    val packet = PacketLiteral(version, typeID)
                    packet.payload = datas.substring(6)
                    _Packets.add(packet)
                    ReadLiteralFlow(packet)
                }
                else -> {
                    val lengthTypeId = datas[6]
                    val packet = PacketOperator(version, typeID)
                    _Packets.add(packet)
                    when (lengthTypeId) {
                        '0' -> {
                            //  Bits to consider
                            packet.lengthTypeId = TREADINGTYPE.BYLENGTH
                            val bitsToConsider = 15
                            val subPacketLengths = datas.substring(7, 7 + bitsToConsider).toInt(2)
                            packet.lengthData = subPacketLengths
                            packet.payload = datas.substring(7 + bitsToConsider)
                            ReadFlowByLengthOfSubPackets(packet.payload, subPacketLengths, operations[typeID]!!) + TYPEIDBIT + bitsToConsider
                        }
                        '1' -> {
                            //  Number of sub packets
                            packet.lengthTypeId = TREADINGTYPE.BYNUMBER
                            val bitsToConsider = 11
                            val numberOfSubPackets = datas.substring(7, 7 + bitsToConsider).toInt(2)
                            packet.lengthData = numberOfSubPackets
                            packet.payload = datas.substring(7 + bitsToConsider)
                            ReadFlowByNumberOfSubPackets(packet.payload, numberOfSubPackets, operations[typeID]!!) + TYPEIDBIT + bitsToConsider
                        }
                        else -> throw Exception("Error generated by Sm3P -> Invalid lengthTypeId")
                    }
                }
            }
        }

        private fun ReadFlowByLengthOfSubPackets(datas : String, subPacketsLength : Int, operation : (MutableList<ReadResult>) -> Long) : ReadResult {
            var read = 0
            val bufferSubPackets = mutableListOf<ReadResult>()
            while(read < subPacketsLength) {
                val subPackets = ReadPacket(datas.substring(read))
                read += PACKETHEADER + subPackets.bitsRead
                bufferSubPackets.add(subPackets)
            }
            return ReadResult(subPacketsLength, operation(bufferSubPackets))
        }

        private fun ReadFlowByNumberOfSubPackets(datas : String, numberOfSubPackets : Int, operation : (MutableList<ReadResult>) -> Long) : ReadResult {
            var subPacketsRead = 0
            var bitsRead = 0
            val bufferSubPackets = mutableListOf<ReadResult>()
            while(subPacketsRead < numberOfSubPackets) {
                val result = ReadPacket(datas.substring(bitsRead))
                subPacketsRead ++
                bitsRead += PACKETHEADER + result.bitsRead
                bufferSubPackets.add(result)
            }

            return ReadResult(bitsRead, operation(bufferSubPackets))
        }

        private fun ReadLiteralFlow(packet : PacketLiteral) : ReadResult {
            //  Sub groups of 5 bits (1 trailing, 4 payload)
            var isLastPacket = false
            var starting = 0
            var chunksRead = 0

            do {
                //  Read next 5 chars
                val chunk = PacketLiteral.Chunk(packet.payload[starting].digitToInt(), packet.payload.substring(starting + 1, starting + 5))
                isLastPacket = chunk.trailingBit == 0
                packet.AddChunk(chunk)
                starting += 5
                chunksRead ++
            } while (isLastPacket == false)

            return ReadResult(chunksRead * 5, packet.ResultNumber)
        }

        private fun String.ConvertToBinary() : String {
            var retValue = ""
            this.forEach { retValue += Integer.toBinaryString(it.toString().toInt(16)).AddPrefix("0", 4)  }
            return retValue
        }

        private fun String.AddPrefix(value : String, length : Int) : String {
            var zeroesToAdd = length - this.length
            return value.repeat(zeroesToAdd) + this
        }

        private operator fun ReadResult.plus(value : Int) : ReadResult = ReadResult(bitsRead + value, resultOperation)
    }

    private enum class TREQUESTTYPE { BASIC, ADVANCED }
    private enum class TPACKETTYPE { OPERATOR, LITERAL }
    private enum class TREADINGTYPE { UNDEf, BYLENGTH, BYNUMBER }
    private abstract class PacketBase(open val version : Int, open val typeId : Int, var packetType : TPACKETTYPE, var payload : String = "")

    private class PacketOperator(override val version : Int, override val typeId : Int, var lengthTypeId : TREADINGTYPE = TREADINGTYPE.UNDEf, var lengthData : Int = 0) : PacketBase(version, typeId, TPACKETTYPE.OPERATOR) {
        override fun toString() : String = "Operator, $lengthTypeId = $lengthData"
    }

    private class PacketLiteral(override val version : Int, override val typeId : Int) : PacketBase(version, typeId, TPACKETTYPE.LITERAL) {
        private val _Chunks = mutableListOf<Chunk>()
        data class Chunk(val trailingBit : Int, val payload : String)

        fun AddChunk(chunk : Chunk) = _Chunks.add(chunk)

        val ResultNumber : Long
            get() = Calculate()

        private fun Calculate() : Long = if(_Chunks.size > 0) _Chunks.joinToString(separator = "") { it.payload }.toLong(2) else 0

        override fun toString() : String = "Literal, chunks: ${_Chunks.size} : $ResultNumber"
    }

    private data class ResultWork(val packets : MutableList<PacketBase>, val resultOperation : Long)

    private fun ParseInput(input : MutableList<String>, requestType : TREQUESTTYPE) : Long {
        var retValue = 0L
        input.forEach { it ->
            if(!it.startsWith("-")) {
                val result = Code(it).DoWork()
                val versionSum = result.packets.sumOf { it.version }
                //println("Version sum: $versionSum, result operations: ${result.resultOperation}")
                retValue = when(requestType) {
                    TREQUESTTYPE.BASIC -> versionSum.toLong()
                    TREQUESTTYPE.ADVANCED -> result.resultOperation
                }
            }
        }
        return retValue
    }
    //endregion
}